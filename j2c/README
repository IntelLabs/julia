Julia2C is a source-to-source translator from Julia to C. This initial version converts basic Julia types and expressions into corresponding C types and statements. 

By translating Julia to C, we leverage the high-level abstractions (matrix, vector, ..), which are easier to analyze, and can potentially add the rich extensions of C (like openmp, tbb, ...). The tool may also extend Julia to new architectures where the only available tool chain is for C.

Usage: 
    User specifies 1 Julia function to be translated into native C.
    In the Julia code generation phase, J2C recursively compiles this function
        and all its direct and indirect callees into C. That is, the whole 
        call graph is translated. 
    A C compiler is invoked to translate the C code into a shared library.
    The original call to the user Julia function is replaced by a call to
        this shared library.

Code Structure:
    There are two main parts of the code:
    1.  Traverse the AST tree of a function. 
        This is embedded into codegen.cpp and a few other files to minimize
            our coding efforts. 

    2.  Map Julia types and AST nodes to C types and statements. 
        This is in j2c.cpp.

An example:
    1. (Optional) Install bcpp, a C beautifier
        sudo apt-get install bcpp    // this works on Ubuntu
        
    2. Checkout the source.
        git clone -b j2c https://github.com/IntelLabs/julia.git j2c

    3. Build
        cd j2c
        make

    4. Run
        export JULIA_ROOT=$PWD
        cd test
        ../julia j2c.jl

    5. Look at the output file
        vi ../j2c/out.cpp

        Some notes: 
        (1) offload(sumOfThree, (Int,)) turns J2C flag on for function sumOfthree.
        (2) sumOfThree(1) invokes code generation for sumOfThree once, where the
            J2C flag is checked, and the function is J2C'ed.
        (3) j2c_sumOfThree calls the J2C'ed sumOfThree().

Current Status:
    C is a static typed language. Therefore, One must make sure the Julia function
    to be converted to C is fully typed. We do not have a checker that checks 
    that condition before translation.
    
    The current release handles only common cases. Search J2C_UNIMPL in src/*.cpp
    for unimplemented cases.
    
    However, with the framework provided, it should be easy for you to add new cases.
    Follow the example of handling arraysize (Other cases are handled in 
    the same way):
        1. After the normal LLVM IR codegen is done, add a call to j2c 
	
             Codegen.cpp line 1859: 
	        if (in_j2c) j2c_arraysize(args[1], idx, ctx, expr);
		
	2. j2c.cpp: add a function for the case.
	    This function builds a result tree, and attaches to it C statements,
	
	    static void j2c_arraysize(jl_value_t *a, uint32_t index, jl_codectx_t *ctx,
	                              jl_value_t *expr)
            {
                // Build a "result tree", whose structure mimics the AST.
		// In this case, expr is the expression arraysize(a, index), 
		// and a is the array, which may be an expresssion itself.
		// The result tree of a has been built before: this is guanranteed
		// since we have followed the code generation process of LLVM IR, which
		// handles the argument (a) first before handling arraysize; 
		// during its handling of a, J2C has already been invoked to build 
		// up the result tree for a.
		
		// We get the result node for each of expr and a, and 
		// connect them as parent-child. The parent-child relationship 
		// is to be used for dumping out the cpp file: all chilldren 
		// must be dumped out before the parent. For example, in this
		// case, since we must evaluate a first before evaluating 
		// arraysize(a), we will dump the result node of a first. 
		
                ast_node_result_t* result = get_ast_node_result(expr, ctx);
		ast_node_result_t* a1 = get_ast_node_result(a, ctx);
		CONNECT_PARENT_CHILD(result, a1);
		
		// Generate a string "t=ARRAYSIZE(a, index)" for the output c file.
		// Here t is a temporary symbol representing the result of the expression.
		// To avoid verbose code generation full of such t's, we actually 
		// propagate constants (the string "ARRAYSIZE(a, index)") on the
		// fly in j2c_copy() and other places.
		
		NEW_C_CODE_4(scratch_str, "ARRAYSIZE(%s, %d)", result_variable_string(a1), index);
		j2c_copy(result, scratch_str);	
            }	
	    
    J2C is reusing the process of LLVM IR code gneration, and thus Step 1 in the above
    example is embedded in the LLVM IR code generator (in codegen.cpp). 
    It is better to separate J2C into a self-contained module or external package. In 
    that way, J2C can be invoked anywhere in Julia, not only in the LLVM IR code generation
    phase.
